// PL/0 Level 2 interpreter using PEG grammar
// Adds: case statements, unconditional break, comparisons, mul/div/mod

module e2peg

import src/peg
import std/os/file
import std/os/path
import std/os/env

pub alias env = list<(string, int)>

pub fun env-get(e: env, key: string): int
  match e.filter(fn(p) p.fst == key)
    Cons((_, v), _) -> v
    Nil -> 0

fun env-set(e: env, key: string, v: int): env
  Cons((key, v), e.filter(fn(p) p.fst != key))

pub type semval
  SVExpr(f: (env) -> <div> int)
  SVStmt(f: (env) -> <div,console,loop-break> env)
  SVIdent(s: string)
  SVList(vs: list<semval>)
  SVArm(cond: (env) -> <div> int, body: (env) -> <div,console,loop-break> env)

pub effect loop-break
  ctl do-break(e: env): a

fun default-action(name: string, txt: string, children: list<semval>, caps: captures<semval>): semval
  if name == "_text" then SVIdent(txt)
  elif name == "_int" || name == "int" then
    val n = txt.list.take-while(fn(c) c.is-digit || c == '-').string.parse-int.default(0)
    SVExpr(fn(_) n)
  elif name == "_str" then SVIdent(txt)
  elif name == "_cons" then
    match txt
      "Assign" -> match children
        Cons(SVIdent(id), Cons(SVExpr(f), _)) -> SVStmt(fn(e) env-set(e, id, f(e)))
        _ -> SVList(children)
      "Decl" -> match children
        Cons(SVIdent(id), _) -> SVStmt(fn(e) env-set(e, id, 0))
        _ -> SVList(children)
      "Int" -> match children
        Cons(SVIdent(s), _) ->
          val n = s.list.take-while(fn(c) c.is-digit).string.parse-int.default(0)
          SVExpr(fn(_) n)
        _ -> SVExpr(fn(_) 0)
      "Ident" -> match children
        Cons(SVIdent(s), _) -> SVIdent(s.list.take-while(fn(c) c.is-alpha || c.is-digit || c == '_').string)
        _ -> SVIdent("")
      "Print" -> match children
        Cons(SVExpr(f), _) -> SVStmt(fn(e) { println(f(e).show); e })
        _ -> SVStmt(fn(e) e)
      "Break" -> SVStmt(fn(e) do-break(e))
      "Loop" -> match children
        Cons(SVStmt(body), _) -> SVStmt(fn(e) exec-loop(e, body))
        _ -> SVStmt(fn(e) e)
      "Block" ->
        val inner = match children { Cons(SVList(vs), _) -> vs; _ -> children }
        val stmts = flatten-sv(inner).filter(fn(c) match c { SVStmt(_) -> True; _ -> False })
        SVStmt(fn(e) stmts.foldl(e, fn(acc, s) match s { SVStmt(f) -> f(acc); _ -> acc }))
      "Case" ->
        val arms = extract-arms(children)
        SVStmt(fn(e) exec-case(e, arms))
      "Arm" -> match children
        Cons(SVExpr(cond), Cons(SVStmt(body), _)) -> SVArm(cond, body)
        _ -> SVList(children)
      "Var" -> match children
        Cons(SVIdent(id), _) -> SVExpr(fn(e) env-get(e, id))
        _ -> SVExpr(fn(_) 0)
      "Neg" -> match children
        Cons(SVExpr(f), _) -> SVExpr(fn(e) 0 - f(e))
        _ -> SVExpr(fn(_) 0)
      "Add" -> binop(children, fn(a, b) a + b)
      "Sub" -> binop(children, fn(a, b) a - b)
      "Mul" -> binop(children, fn(a, b) a * b)
      "Div" -> binop(children, fn(a, b) if b == 0 then 0 else a / b)
      "Mod" -> binop(children, fn(a, b) if b == 0 then 0 else a % b)
      "Eq" -> binop(children, fn(a, b) if a == b then 1 else 0)
      "Ne" -> binop(children, fn(a, b) if a != b then 1 else 0)
      "Lt" -> binop(children, fn(a, b) if a < b then 1 else 0)
      "Gt" -> binop(children, fn(a, b) if a > b then 1 else 0)
      "Le" -> binop(children, fn(a, b) if a <= b then 1 else 0)
      "Ge" -> binop(children, fn(a, b) if a >= b then 1 else 0)
      _ -> SVList(children)
  elif name == "_lit" then SVList(children)
  else match children
    Cons(c, Nil) -> c
    _ -> SVList(children)

fun binop(children: list<semval>, op: (int, int) -> int): semval
  match children
    Cons(SVExpr(l), Cons(SVExpr(r), _)) -> SVExpr(fn(e) op(l(e), r(e)))
    _ -> SVExpr(fn(_) 0)

fun exec-loop(e: env, body: (env) -> <div,console,loop-break> env): <div,console,loop-break> env
  with ctl do-break(e1) e1
  exec-loop(body(e), body)

fun exec-case(e: env, arms: list<((env) -> <div> int, (env) -> <div,console,loop-break> env)>): <div,console,loop-break> env
  match arms
    Cons((cond, body), rest) -> if cond(e) != 0 then body(e) else exec-case(e, rest)
    Nil -> e

fun flatten-sv(vs: list<semval>): list<semval>
  vs.flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })
    .flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })
    .flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })

fun extract-arms(vs: list<semval>): list<((env) -> <div> int, (env) -> <div,console,loop-break> env)>
  flatten-sv(vs).filter-map fn(c)
    match c
      SVArm(cond, body) -> Just((cond, body))
      _ -> Nothing

fun actions(): actions<semval>
  []

fun exec-safe(v: semval, e: env): <div, console> env
  with ctl do-break(e1)
    println("Error: 'break' used outside of loop")
    e1
  match v
    SVStmt(f) -> f(e)
    SVList(Cons(x, _)) -> exec-safe(x, e)
    _ -> e

pub fun main()
  val args = get-args()
  val prog-path = match args { Cons(p, _) -> p; Nil -> "examples/example.e2" }
  val arg1-val = match args { Cons(_, Cons(n, _)) -> n.parse-int.default(0); _ -> 0 }
  val arg2-val = match args { Cons(_, Cons(_, Cons(n, _))) -> n.parse-int.default(0); _ -> 0 }

  val grammar-text = read-text-file("src/e2.peg".path)
  val g = parse-peg(grammar-text)
  val prog = read-text-file(prog-path.path)
  println("e2: " ++ prog-path ++ " (" ++ prog.count.int/show ++ " chars)")

  var input := prog.slice
  var current-env: env := [("arg1", arg1-val), ("arg2", arg2-val)]

  match peg-exec-partial(g, actions(), default-action, "_", input)
    Just((rest, _)) -> input := rest
    Nothing -> ()

  while { !input.is-empty }
    match peg-exec-partial(g, actions(), default-action, "statement", input)
      Just((rest, sv)) ->
        current-env := exec-safe(sv, current-env)
        match peg-exec-partial(g, actions(), default-action, "_", rest)
          Just((rest2, _)) -> input := rest2
          Nothing -> input := rest
      Nothing ->
        if !input.is-empty then println("Parse failed at: " ++ input.string.first(20).string ++ "...")
        input := "".slice

  println("")
