// PL/0 Level 2 interpreter using PEG grammar
// Adds: case, break, comparisons, mul/div/mod

module e2peg

import src/peg
import src/pegeval

pub type e2ext
  E2Arm(cond: (penv) -> <div> int, body: (penv) -> <div,console,loop-break> penv)

pub alias e2val = semval<e2ext>

fun e2-binop(children: list<e2val>, op: (int, int) -> int): e2val
  match children
    Cons(SVExpr(l), Cons(SVExpr(r), _)) -> SVExpr(fn(e) op(l(e), r(e)))
    _ -> SVExpr(fn(_) 0)

fun exec-case(e: penv, arms: list<e2val>): <div,console,loop-break> penv
  match arms
    Cons(SVExt(E2Arm(cond, body)), rest) -> if cond(e) != 0 then body(e) else exec-case(e, rest)
    _ -> e

fun e2-action(name: string, txt: string, children: list<e2val>, _caps: captures<e2val>): e2val
  if name == "_cons" then match txt
    "Mul" -> e2-binop(children, fn(a, b) a * b)
    "Div" -> e2-binop(children, fn(a, b) if b == 0 then 0 else a / b)
    "Mod" -> e2-binop(children, fn(a, b) if b == 0 then 0 else a % b)
    "Eq" -> e2-binop(children, fn(a, b) if a == b then 1 else 0)
    "Ne" -> e2-binop(children, fn(a, b) if a != b then 1 else 0)
    "Lt" -> e2-binop(children, fn(a, b) if a < b then 1 else 0)
    "Gt" -> e2-binop(children, fn(a, b) if a > b then 1 else 0)
    "Le" -> e2-binop(children, fn(a, b) if a <= b then 1 else 0)
    "Ge" -> e2-binop(children, fn(a, b) if a >= b then 1 else 0)
    "StmtArm" -> match children
      Cons(SVExpr(cond), Cons(SVStmt(body), _)) -> SVExt(E2Arm(cond, body))
      _ -> SVList(children)
    "CaseStmt" ->
      val arms = flatten-sv(children).filter(fn(c) match c { SVExt(_) -> True; _ -> False })
      SVStmt(fn(e) exec-case(e, arms))
    _ -> handle-base(name, txt, children).default(SVList(children))
  else handle-base(name, txt, children).default(SVList(children))

fun exec-ext(_x: e2ext, e: penv): <div,console,loop-break> penv
  e

pub fun main()
  run-interpreter("e2", "src/e2.peg", "examples/example.e2", e2-action, exec-ext,
    "Error: 'break' used outside of loop")
