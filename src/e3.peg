// PL/0 Level 3 Grammar (PEG variant)
// Adds: booleans, callables (closures), case expressions, function application

program         = _ statement*
statement       = binding / case_stmt / loop_stmt / break_stmt / print_stmt / block / expression

block           = "{" _ (statement ";"? _)* "}" _ { Block }
loop_stmt       = "loop" _ body:statement { Loop($body) }
break_stmt      = "break" _ { Break }
print_stmt      = "print" _ e:expression { Print($e) }
case_stmt       = "case" _ "{" _ stmt_arm+ "}" _ { CaseStmt }
stmt_arm        = cond:or_expr "->" _ body:statement { StmtArm($cond, $body) }

binding         = id:ident _ ":=" _ e:expression { Assign($id, $e) }
                / id:ident _ ":" { Decl($id) }

expression      = &("(" _ (ident (_ "," _ ident)* _)? ")" _ "->") func_lit / case_expr / or_expr
case_expr       = "case" _ "{" _ expr_arm+ "}" _ { CaseExpr }
expr_arm        = cond:or_expr "->" _ val:or_expr ","? _ { ExprArm($cond, $val) }

or_expr         = l:and_expr "||" _ r:or_expr { Or($l, $r) }
                / and_expr
and_expr        = l:not_expr "&&" _ r:and_expr { And($l, $r) }
                / not_expr
not_expr        = "!" _ e:cmp_expr { Not($e) }
                / cmp_expr

cmp_expr        = l:sum_expr "==" _ r:sum_expr { Eq($l, $r) }
                / l:sum_expr "!=" _ r:sum_expr { Ne($l, $r) }
                / l:sum_expr "<=" _ r:sum_expr { Le($l, $r) }
                / l:sum_expr ">=" _ r:sum_expr { Ge($l, $r) }
                / l:sum_expr "<" _ r:sum_expr { Lt($l, $r) }
                / l:sum_expr ">" _ r:sum_expr { Gt($l, $r) }
                / sum_expr

sum_expr        = l:product "+" _ r:sum_expr { Add($l, $r) }
                / l:product "-" _ r:sum_expr { Sub($l, $r) }
                / product
product         = l:unary "*" _ r:product { Mul($l, $r) }
                / l:unary "/" _ r:product { Div($l, $r) }
                / l:unary "%" _ r:product { Mod($l, $r) }
                / unary
unary           = "-" _ e:apply_expr { Neg($e) }
                / apply_expr

apply_expr      = atom (__ atom)* _
atom            = int_lit / bool_lit / paren_expr / id:ident { Var($id) } / block
paren_expr      = "(" _ e:expression ")" { $e }

int_lit         = digit+ { Int($0) }
bool_lit        = "true" !idchar { True }
                / "false" !idchar { False }
func_lit        = "(" _ p:params? ")" _ "->" _ body:expression { Func($p, $body) }
params          = ident _ ("," _ ident _)* ","? _ { Params }

keyword         = ("case" / "loop" / "break" / "true" / "false" / "print") !idchar
ident           = !keyword letter idchar* { Ident($0) }
idchar          = [a-zA-Z0-9_]
letter          = [a-zA-Z]
digit           = [0-9]

_               = ([ \t\n\r] / comment)*
__              = [ \t]+
comment         = "//" [^\n]* / "/*" (!"*/" .)* "*/"
