// PL/0 Grammar (PEG variant)
//
// Four types with their algebraic operations:
//   ‚Ñ§ (integers)   ‚Äî Euclidean domain: + - * / %
//   ùîπ (booleans)   ‚Äî Boolean algebra: && || !
//   [T] (arrays)   ‚Äî application via juxtaposition or dot
//   () ‚Üí T (funcs) ‚Äî application via juxtaposition
//
// Access:
//   f x       ‚Äî evaluated (juxtaposition)
//   arr.0     ‚Äî literal index (dot)
//
// Type bridge: relational operators ‚Ñ§ √ó ‚Ñ§ ‚Üí ùîπ

// Program structure
program         = _ top_level_stmt*

// Statements
top_level_stmt  = binding / expression
statement       = control / print_stmt / top_level_stmt

// Control flow
control         = case_stmt / loop_stmt / "break" _
case_stmt       = "case" _ or_expr? "{" _ stmt_arm+ "}" _
stmt_arm        = pattern "->" _ statement
loop_stmt       = "loop" _ statement
print_stmt      = "print" _ expression

// Blocks
block           = "{" _ (statement ";"? _)* expression? "}" _

// Bindings
binding         = ident _ ":" ("=" _ expression)?
                / lvalue _ ":=" _ expression
lvalue          = ident accessor+
accessor        = __ atom / "." _ (int_lit / ident)

// Unified expression grammar
expression      = or_expr
case_expr       = "case" _ or_expr? "{" _ expr_arm+ "}" _
expr_arm        = pattern "->" _ or_expr ("," _)?

// ùîπ operations
or_expr         = and_expr ("||" _ and_expr)*
and_expr        = not_expr ("&&" _ not_expr)*
not_expr        = ("!" _)? cmp_expr

// Type bridge
cmp_expr        = sum_expr (relop sum_expr)?
relop           = ("==" / "!=" / "<=" / ">=" / "<" / ">") _

// ‚Ñ§ operations
sum_expr        = product (("+" / "-") _ product)*
product         = unary (("*" / "/" / "%") _ unary)*
unary           = "-"? apply_expr

// Application: juxtaposition or dot
apply_expr      = atom (__ atom / "." _ (int_lit / ident))*
tuple_items     = expression ("," _ expression)* ("," _)?
array_items     = (expression ";" _)+

atom            = literal / ident / paren_expr / block / case_expr

paren_expr      = "(" _ (array_items / tuple_items)? _ ")" _

// Literals
literal         = int_lit / bool_lit / func_lit
int_lit         = digit+ _
bool_lit        = ("true" / "false") !idchar _
func_lit        = "\\" _ params? "->" _ expression
params          = ident ("," _ ident)* ("," _)?

// Lexical elements
keyword         = ("case" / "loop" / "break" / "true" / "false" / "print") !idchar
ident           = !keyword letter idchar* _
wildcard        = "_" !idchar _
idchar          = [a-zA-Z0-9_]
letter          = [a-zA-Z]
digit           = [0-9]

// Patterns
pattern         = wildcard
                / paren_pat
                / literal
                / ident

paren_pat       = "(" _ (array_pat_items / pattern)? _ ")" _
array_pat_items = (pattern ";" _)+

// Whitespace and comments
_               = ([ \t\n\r] / comment)*
__              = [ \t]+
comment         = "//" [^\n]* / "/*" (!"*/" .)* "*/"
