// PL/0 Level 4 Grammar (PEG variant)
// Adds: arrays, pattern matching (on top of e3: booleans, closures)

program         = _ statement*
statement       = binding / case_stmt / loop_stmt / break_stmt / print_stmt / block / expression

block           = "{" _ (statement ";"? _)* "}" _ { Block }
loop_stmt       = "loop" _ body:statement { Loop($body) }
break_stmt      = "break" _ { Break }
print_stmt      = "print" _ e:expression { Print($e) }
case_stmt       = "case" _ scrut:or_expr "{" _ stmt_arm+ "}" _ { CaseStmt }
stmt_arm        = pat:pattern "->" _ body:statement { StmtArm($pat, $body) }

binding         = id:ident _ ":=" _ e:expression { Assign($id, $e) }
                / id:ident _ ":" { Decl($id) }

expression      = func_lit / case_expr / or_expr
case_expr       = "case" _ scrut:or_expr "{" _ expr_arm+ "}" _ { CaseExpr }
expr_arm        = pat:pattern "->" _ val:or_expr ","? _ { ExprArm($pat, $val) }

// Refactored to avoid backtracking: use left-factored rules
or_expr         = and_expr or_tail*
or_tail         = "||" _ and_expr { Or }
and_expr        = not_expr and_tail*
and_tail        = "&&" _ not_expr { And }
not_expr        = "!" _ e:cmp_expr { Not($e) }
                / cmp_expr

cmp_expr        = sum_expr cmp_tail?
cmp_tail        = "==" _ r:sum_expr { Eq }
                / "!=" _ r:sum_expr { Ne }
                / "<=" _ r:sum_expr { Le }
                / ">=" _ r:sum_expr { Ge }
                / "<" _ r:sum_expr { Lt }
                / ">" _ r:sum_expr { Gt }

sum_expr        = product sum_tail*
sum_tail        = "+" _ product { Add }
                / "-" _ product { Sub }
product         = unary product_tail*
product_tail    = "*" _ unary { Mul }
                / "/" _ unary { Div }
                / "%" _ unary { Mod }
unary           = "-" _ e:apply_expr { Neg($e) }
                / apply_expr

// Application and indexing
// Note: atom_raw doesn't consume trailing whitespace, apply_tail handles it
apply_expr      = atom_raw apply_tail* _
apply_tail      = _ "." _ idx:int_lit_raw { DotIndex($idx) }
                / __ arg:atom_raw { Apply($arg) }

atom_raw        = int_lit_raw / bool_lit_raw / paren_expr / id:ident_raw { Var($id) } / block

// Parenthesized: array literal, unit, or grouped expression
paren_expr      = "(" _ ")" _ { Unit }
                / "(" _ array_items ")" _ { Array }
                / "(" _ e:expression ")" _ { $e }
array_items     = expression (";" _ expression)* ";"? _

int_lit_raw     = digit+ { Int($0) }
int_lit         = digit+ _ { Int($0) }
bool_lit_raw    = "true" !idchar { True }
                / "false" !idchar { False }
bool_lit        = "true" !idchar _ { True }
                / "false" !idchar _ { False }
func_lit        = "\\" _ p:params? "->" _ body:expression { Func($p, $body) }
params          = ident _ ("," _ ident _)* ","? _ { Params }

keyword         = ("case" / "loop" / "break" / "true" / "false" / "print") !idchar
ident_raw       = !keyword letter idchar* { Ident($0) }
ident           = !keyword letter idchar* _ { Ident($0) }
idchar          = [a-zA-Z0-9_]
letter          = [a-zA-Z]
digit           = [0-9]

// Patterns
pattern         = "_" !idchar _ { PWild }
                / paren_pat
                / lit:int_lit { PLit($lit) }
                / "true" !idchar _ { PLitTrue }
                / "false" !idchar _ { PLitFalse }
                / id:ident { PVar($id) }

paren_pat       = "(" _ ")" _ { PUnit }
                / "(" _ array_pat_items ")" _ { PArray }
array_pat_items = pattern (";" _ pattern)* ";"? _

_               = ([ \t\n\r] / comment)*
__              = [ \t]+
comment         = "//" [^\n]* / "/*" (!"*/" .)* "*/"
