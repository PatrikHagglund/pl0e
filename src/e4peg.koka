// PL/0 Level 4 interpreter using PEG grammar
// Adds arrays and pattern matching to e3

module e4peg

import src/peg
import std/os/file
import std/os/path
import std/os/env

// Runtime values
pub type rval
  VInt(n: int)
  VBool(b: bool)
  VArray(v: vector<rval>)
  VClosure(params: list<string>, body: expr, env: e4env)

pub alias e4env = list<(string, rval)>

// Patterns
pub type pattern
  PWild
  PVar(name: string)
  PLit(v: rval)
  PArray(elems: list<pattern>, rest: bool)  // rest=true means prefix match

// Expressions
pub type expr
  EVal(v: rval)
  EVar(s: string)
  EBinop(op: string, l: expr, r: expr)
  ENot(e: expr)
  ENeg(e: expr)
  EApply(f: expr, a: expr)
  EIndex(arr: expr, idx: int)
  ECase(scrut: expr, arms: list<(pattern, expr)>)
  EFunc(params: list<string>, body: expr)
  EArray(elems: list<expr>)

// Statements
pub type stmt
  SExpr(e: expr)
  SAssign(id: string, e: expr)
  SDecl(id: string)
  SPrint(e: expr)
  SLoop(body: stmt)
  SBreak
  SBlock(stmts: list<stmt>)
  SCaseStmt(scrut: expr, arms: list<(pattern, stmt)>)

// Semantic values for PEG actions
pub type semval
  SVExpr(e: expr)
  SVStmt(s: stmt)
  SVIdent(s: string)
  SVPat(p: pattern)
  SVList(vs: list<semval>)
  SVExprArm(pat: pattern, body: expr)
  SVStmtArm(pat: pattern, body: stmt)
  SVBinopTail(op: string, rhs: expr)
  SVIndex(idx: int)

fun env-get(e: e4env, key: string): rval
  match e.filter(fn(p) p.fst == key)
    Cons((_, v), _) -> v
    Nil -> VInt(0)

fun env-set(e: e4env, key: string, v: rval): e4env
  Cons((key, v), e.filter(fn(p) p.fst != key))

fun env-extend(e: e4env, bindings: list<(string, rval)>): e4env
  bindings.foldl(e, fn(acc, b) env-set(acc, b.fst, b.snd))

// Pattern matching - returns bindings on success
fun match-pattern(p: pattern, v: rval): div maybe<list<(string, rval)>>
  match (p, v)
    (PWild, _) -> Just([])
    (PVar(name), _) -> Just([(name, v)])
    (PLit(pv), _) -> if rval-eq(pv, v) then Just([]) else Nothing
    (PArray(elems, rest), VArray(arr)) ->
      val len = arr.length
      val plen = elems.length
      if rest then
        if len < plen then Nothing
        else match-array-elems(elems, arr, 0)
      else
        if len != plen then Nothing
        else match-array-elems(elems, arr, 0)
    _ -> Nothing

fun match-array-elems(pats: list<pattern>, arr: vector<rval>, idx: int): div maybe<list<(string, rval)>>
  match pats
    Nil -> Just([])
    Cons(p, rest) ->
      match arr.at(idx)
        Nothing -> Nothing
        Just(v) -> match match-pattern(p, v)
          Nothing -> Nothing
          Just(binds) -> match match-array-elems(rest, arr, idx + 1)
            Nothing -> Nothing
            Just(more) -> Just(binds ++ more)

fun rval-eq(a: rval, b: rval): bool
  match (a, b)
    (VInt(x), VInt(y)) -> x == y
    (VBool(x), VBool(y)) -> x == y
    _ -> False

effect loop-break
  ctl do-break(e: e4env): a

fun eval(ex: expr, e: e4env): <div> rval
  match ex
    EVal(v) -> v
    EVar(s) -> env-get(e, s)
    EArray(elems) -> VArray(elems.map(fn(el) eval(el, e)).vector)
    EIndex(arr, idx) ->
      match eval(arr, e)
        VArray(v) -> v.at(idx).default(VInt(0))
        _ -> VInt(0)
    EBinop(op, l, r) ->
      val lv = eval(l, e)
      val rv = eval(r, e)
      match (op, lv, rv)
        ("+", VInt(a), VInt(b)) -> VInt(a + b)
        ("-", VInt(a), VInt(b)) -> VInt(a - b)
        ("*", VInt(a), VInt(b)) -> VInt(a * b)
        ("/", VInt(a), VInt(b)) -> VInt(if b == 0 then 0 else a / b)
        ("%", VInt(a), VInt(b)) -> VInt(if b == 0 then 0 else a % b)
        ("==", VInt(a), VInt(b)) -> VBool(a == b)
        ("!=", VInt(a), VInt(b)) -> VBool(a != b)
        ("<", VInt(a), VInt(b)) -> VBool(a < b)
        (">", VInt(a), VInt(b)) -> VBool(a > b)
        ("<=", VInt(a), VInt(b)) -> VBool(a <= b)
        (">=", VInt(a), VInt(b)) -> VBool(a >= b)
        ("&&", VBool(a), VBool(b)) -> VBool(a && b)
        ("||", VBool(a), VBool(b)) -> VBool(a || b)
        _ -> VInt(0)
    ENot(inner) -> match eval(inner, e)
      VBool(b) -> VBool(!b)
      _ -> VBool(False)
    ENeg(inner) -> match eval(inner, e)
      VInt(n) -> VInt(0 - n)
      _ -> VInt(0)
    EApply(f, a) ->
      val fv = eval(f, e)
      val av = eval(a, e)
      match (fv, av)
        (VArray(arr), VInt(idx)) -> arr.at(idx).default(VInt(0))
        (VClosure(params, body, cenv), _) ->
          match params
            Cons(p, rest) ->
              val newenv = env-set(cenv, p, av)
              if rest.is-nil then eval(body, newenv)
              else VClosure(rest, body, newenv)
            Nil -> eval(body, cenv)
        _ -> VInt(0)
    ECase(scrut, arms) ->
      val sv = eval(scrut, e)
      eval-case-arms(sv, arms, e)
    EFunc(params, body) -> VClosure(params, body, e)

fun eval-case-arms(scrut: rval, arms: list<(pattern, expr)>, e: e4env): <div> rval
  match arms
    Nil -> VInt(0)
    Cons((pat, body), rest) ->
      match match-pattern(pat, scrut)
        Just(binds) -> eval(body, env-extend(e, binds))
        Nothing -> eval-case-arms(scrut, rest, e)

fun exec(s: stmt, e: e4env): <div,console,loop-break> e4env
  match s
    SExpr(_) -> e
    SAssign(id, ex) -> env-set(e, id, eval(ex, e))
    SDecl(id) -> env-set(e, id, VInt(0))
    SPrint(ex) ->
      println(show-rval(eval(ex, e)))
      e
    SLoop(body) ->
      with ctl do-break(e1) e1
      fun go(env: e4env): <div,console,loop-break> e4env
        go(exec(body, env))
      go(e)
    SBreak -> do-break(e)
    SBlock(stmts) -> stmts.foldl(e, fn(acc, st) exec(st, acc))
    SCaseStmt(scrut, arms) ->
      val sv = eval(scrut, e)
      exec-case-arms(sv, arms, e)

fun exec-case-arms(scrut: rval, arms: list<(pattern, stmt)>, e: e4env): <div,console,loop-break> e4env
  match arms
    Nil -> e
    Cons((pat, body), rest) ->
      match match-pattern(pat, scrut)
        Just(binds) -> exec(body, env-extend(e, binds))
        Nothing -> exec-case-arms(scrut, rest, e)

fun show-rval(v: rval): div string
  match v
    VInt(n) -> n.show
    VBool(b) -> if b then "true" else "false"
    VArray(arr) ->
      if arr.length == 0 then "()"
      else "(" ++ arr.list.map(show-rval).join("; ") ++ ";)"
    VClosure(_, _, _) -> "<closure>"

// Semantic action helpers
fun flatten-sv(vs: list<semval>): list<semval>
  vs.flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })

fun get-params(vs: list<semval>): list<string>
  flatten-sv(vs).filter-map(fn(v) match v { SVIdent(s) -> Just(s); _ -> Nothing })

fun sv-to-stmt(v: semval): maybe<stmt>
  match v
    SVStmt(s) -> Just(s)
    SVExpr(ex) -> Just(SExpr(ex))
    _ -> Nothing

fun sv-to-expr(v: semval): maybe<expr>
  match v { SVExpr(e) -> Just(e); _ -> Nothing }

fun sv-to-pat(v: semval): maybe<pattern>
  match v { SVPat(p) -> Just(p); _ -> Nothing }

fun fold-binop-tails(base: expr, tails: list<semval>): expr
  tails.foldl(base) fn(acc, tail)
    match tail
      SVBinopTail(op, rhs) -> EBinop(op, acc, rhs)
      _ -> acc

fun ident-str(v: semval): string
  match v
    SVIdent(s) -> s.list.take-while(fn(c) c.is-alpha || c.is-digit || c == '_').string
    _ -> ""

fun e4-action(name: string, txt: string, children: list<semval>, caps: captures<semval>): semval
  val cs = flatten-sv(children)
  if name == "_text" then SVIdent(txt)
  // Binary expression rules
  elif name == "or_expr" || name == "and_expr" || name == "sum_expr" || name == "product" then
    match cs
      Cons(SVExpr(base), rest) -> SVExpr(fold-binop-tails(base, rest))
      _ -> SVList(cs)
  elif name == "cmp_expr" then
    match cs
      Cons(SVExpr(base), Cons(SVBinopTail(op, rhs), _)) -> SVExpr(EBinop(op, base, rhs))
      Cons(SVExpr(base), _) -> SVExpr(base)
      _ -> SVList(cs)
  elif name == "or_tail" then
    match cs { Cons(SVExpr(rhs), _) -> SVBinopTail("||", rhs); _ -> SVList(cs) }
  elif name == "and_tail" then
    match cs { Cons(SVExpr(rhs), _) -> SVBinopTail("&&", rhs); _ -> SVList(cs) }
  elif name == "sum_tail" then
    match cs
      Cons(SVExpr(rhs), _) -> SVBinopTail(if txt.starts-with("+").bool then "+" else "-", rhs)
      _ -> SVList(cs)
  elif name == "product_tail" then
    val op = if txt.starts-with("*").bool then "*" elif txt.starts-with("/").bool then "/" else "%"
    match cs { Cons(SVExpr(rhs), _) -> SVBinopTail(op, rhs); _ -> SVList(cs) }
  elif name == "cmp_tail" then
    val op = if txt.starts-with("==").bool then "=="
             elif txt.starts-with("!=").bool then "!="
             elif txt.starts-with("<=").bool then "<="
             elif txt.starts-with(">=").bool then ">="
             elif txt.starts-with("<").bool then "<"
             else ">"
    match cs { Cons(SVExpr(rhs), _) -> SVBinopTail(op, rhs); _ -> SVList(cs) }
  // Apply expression with indexing
  elif name == "apply_expr" then
    cs.foldl(SVList([]): semval) fn(acc, c)
      match (acc, c)
        (SVList([]), SVExpr(e)) -> SVExpr(e)
        (SVExpr(base), SVIndex(idx)) -> SVExpr(EIndex(base, idx))
        (SVExpr(base), SVExpr(arg)) -> SVExpr(EApply(base, arg))
        _ -> acc
  elif name == "array_items" then
    SVList(cs)
  elif name == "array_pat_items" then
    SVList(cs)
  elif name == "_cons" then match txt
    "Int" -> match cs
      Cons(SVIdent(s), _) -> SVExpr(EVal(VInt(s.list.take-while(is-digit).string.parse-int.default(0))))
      _ -> SVExpr(EVal(VInt(0)))
    "True" -> SVExpr(EVal(VBool(True)))
    "False" -> SVExpr(EVal(VBool(False)))
    "Ident" -> SVIdent(cs.head.default(SVIdent("")).ident-str)
    "Var" -> SVExpr(EVar(cs.head.default(SVIdent("")).ident-str))
    "Assign" -> match cs
      Cons(SVIdent(id), Cons(SVExpr(e), _)) -> SVStmt(SAssign(id, e))
      _ -> SVList(cs)
    "Not" -> match cs { Cons(SVExpr(e), _) -> SVExpr(ENot(e)); _ -> SVExpr(EVal(VBool(False))) }
    "Neg" -> match cs { Cons(SVExpr(e), _) -> SVExpr(ENeg(e)); _ -> SVExpr(EVal(VInt(0))) }
    "Decl" -> match cs { Cons(SVIdent(id), _) -> SVStmt(SDecl(id)); _ -> SVList(cs) }
    "Print" -> match cs { Cons(SVExpr(e), _) -> SVStmt(SPrint(e)); _ -> SVList(cs) }
    "Loop" -> match cs { Cons(SVStmt(s), _) -> SVStmt(SLoop(s)); _ -> SVList(cs) }
    "Break" -> SVStmt(SBreak)
    "Block" -> SVStmt(SBlock(flatten-sv(cs).filter-map(sv-to-stmt)))
    "Params" -> SVList(cs)
    "Func" ->
      val params = get-params(cs.init)
      match cs.last { Just(SVExpr(body)) -> SVExpr(EFunc(params, body)); _ -> SVList(cs) }
    "Unit" -> SVExpr(EVal(VArray([].vector)))
    "Array" ->
      val exprs = flatten-sv(cs).filter-map(sv-to-expr)
      SVExpr(EArray(exprs))
    "DotIndex" -> match cs
      Cons(SVExpr(EVal(VInt(idx))), _) -> SVIndex(idx)
      _ -> SVList(cs)
    "Apply" -> match cs { Cons(SVExpr(e), _) -> SVExpr(e); _ -> SVList(cs) }
    // Patterns
    "PWild" -> SVPat(PWild)
    "PVar" -> SVPat(PVar(cs.head.default(SVIdent("")).ident-str))
    "PLit" -> match cs
      Cons(SVExpr(EVal(v)), _) -> SVPat(PLit(v))
      _ -> SVPat(PWild)
    "PLitTrue" -> SVPat(PLit(VBool(True)))
    "PLitFalse" -> SVPat(PLit(VBool(False)))
    "PUnit" -> SVPat(PArray([], False))
    "PArray" ->
      val pats = flatten-sv(cs).filter-map(sv-to-pat)
      // Check if last pattern is wildcard -> rest match
      val (elems, rest) = match pats.reverse
        Cons(PWild, rrest) -> (rrest.reverse, True)
        _ -> (pats, False)
      SVPat(PArray(elems, rest))
    // Case arms
    "ExprArm" -> match cs
      Cons(SVPat(pat), Cons(SVExpr(body), _)) -> SVExprArm(pat, body)
      _ -> SVList(cs)
    "StmtArm" -> match cs
      Cons(SVPat(pat), Cons(SVStmt(body), _)) -> SVStmtArm(pat, body)
      _ -> SVList(cs)
    "CaseExpr" ->
      // First child is scrutinee, rest are arms
      val (scrut, arm-children) = match cs
        Cons(SVExpr(e), rest) -> (e, rest)
        _ -> (EVal(VBool(True)), cs)
      val arms = flatten-sv(arm-children).filter-map fn(v)
        match v { SVExprArm(p, b) -> Just((p, b)); _ -> Nothing }
      SVExpr(ECase(scrut, arms))
    "CaseStmt" ->
      // First child is scrutinee, rest are arms
      val (scrut, arm-children) = match cs
        Cons(SVExpr(e), rest) -> (e, rest)
        _ -> (EVal(VBool(True)), cs)
      val arms = flatten-sv(arm-children).filter-map fn(v)
        match v { SVStmtArm(p, b) -> Just((p, b)); _ -> Nothing }
      SVStmt(SCaseStmt(scrut, arms))
    _ -> SVList(cs)
  else match cs
    Cons(c, Nil) -> c
    _ -> SVList(cs)

fun exec-safe(sv: semval, e: e4env): <div,console> e4env
  with ctl do-break(e1)
    println("Error: 'break' used outside of loop")
    e1
  match sv
    SVStmt(s) -> exec(s, e)
    SVList(Cons(SVStmt(s), _)) -> exec(s, e)
    _ -> e

fun parse-flags(args: list<string>): div (bool, bool, bool, list<string>)
  match args
    Cons("--dump", rest) ->
      val (_, w, s, r) = parse-flags(rest)
      (True, w, s, r)
    Cons("--warn", rest) ->
      val (d, _, s, r) = parse-flags(rest)
      (d, True, s, r)
    Cons("--stats", rest) ->
      val (d, w, _, r) = parse-flags(rest)
      (d, w, True, r)
    Cons(x, rest) ->
      val (d, w, s, r) = parse-flags(rest)
      (d, w, s, Cons(x, r))
    Nil -> (False, False, False, [])

pub fun main()
  val args = get-args()
  val (do-dump, do-warn, do-stats, rest-args) = parse-flags(args)

  val prog-path = match rest-args { Cons(p, _) -> p; Nil -> "examples/example.e4" }
  val arg1-val = match rest-args { Cons(_, Cons(n, _)) -> n.parse-int.default(0); _ -> 0 }
  val arg2-val = match rest-args { Cons(_, Cons(_, Cons(n, _))) -> n.parse-int.default(0); _ -> 0 }

  println("loading grammar...")
  val g = parse-peg(read-text-file("src/e4.peg".path))
  if do-dump then
    println("loaded " ++ g.length.show ++ " rules")
    println(show-grammar(g))
    return ()
  if do-warn then
    val warnings = warn-grammar(g)
    if warnings.is-empty then println("No warnings")
    else warnings.foreach(fn(w) println("Warning: " ++ w))
  val prog = read-text-file(prog-path.path)
  println("e4: " ++ prog-path ++ " (" ++ prog.count.int/show ++ " chars)")

  if do-stats then
    val (result, stats) = peg-exec-stats(g, [], e4-action, "program", prog)
    match result
      Just(_) -> ()
      Nothing -> println("Parse failed")
    println(show-stats(stats))
  else
    var input := prog.slice
    var current-env: e4env := [("arg1", VInt(arg1-val)), ("arg2", VInt(arg2-val))]

    match peg-exec-partial(g, [], e4-action, "_", input)
      (_, Just((rest, _))) -> input := rest
      _ -> ()

    while { !input.is-empty }
      match peg-exec-partial(g, [], e4-action, "statement", input)
        (_, Just((rest, sv))) ->
          current-env := exec-safe(sv, current-env)
          match peg-exec-partial(g, [], e4-action, "_", rest)
            (_, Just((rest2, _))) -> input := rest2
            _ -> input := rest
        _ ->
          if !input.is-empty then println("Parse failed at: " ++ input.string.first(20).string ++ "...")
          input := "".slice
    println("")
