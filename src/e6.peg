// PL/0 Grammar (PEG variant) - Level 5: Static Typing
//
// Adds to Level 4:
//   Type declarations: type Point = {x: int, y: int}
//   Typed bindings: x: int = 5
//   Typed parameters: (x: int, y: int) -> ...
//
// Access:
//   f x       ‚Äî evaluated (juxtaposition)
//   rec.field ‚Äî literal field (dot)
//   arr.0     ‚Äî literal index (dot)

// Program structure
program         = _ top_level_stmt*

// Statements
top_level_stmt  = type_decl / binding / expression
statement       = control / print_stmt / top_level_stmt

type_decl       = "type" _ ident "=" _ type_expr

// Control flow
control         = case_stmt / loop_stmt / "break" _
case_stmt       = "case" _ or_expr? "{" _ stmt_arm+ "}" _
stmt_arm        = pattern "->" _ statement
loop_stmt       = "loop" _ statement
print_stmt      = "print" _ expression

// Blocks
block           = "{" _ (statement ";"? _)* expression? "}" _

// Bindings with explicit types
binding         = ident _ ":" _ type_expr? ("=" _ expression)?
                / lvalue _ ":=" _ expression
lvalue          = ident accessor+
accessor        = __ atom / "." _ (int_lit / ident)

// Type Expressions
type_expr       = func_type / array_type / record_type / basic_type / ident
basic_type      = ("int" / "bool" / "unit") !idchar _
array_type      = "[" _ type_expr _ "]" _
record_type     = "{" _ record_type_fields? "}" _
record_type_fields = param ("," _ param)* ("," _)?
func_type       = (record_type / "(" _ type_expr? _ ")" _) "->" _ type_expr

// Unified expression grammar
expression      = or_expr
case_expr       = "case" _ or_expr? "{" _ expr_arm+ "}" _
expr_arm        = pattern "->" _ or_expr ("," _)?

// ùîπ operations
or_expr         = and_expr ("||" _ and_expr)*
and_expr        = not_expr ("&&" _ not_expr)*
not_expr        = ("!" _)? cmp_expr

// Type bridge
cmp_expr        = sum_expr (relop sum_expr)?
relop           = ("==" / "!=" / "<=" / ">=" / "<" / ">") _

// ‚Ñ§ operations
sum_expr        = product (("+" / "-") _ product)*
product         = unary (("*" / "/" / "%") _ unary)*
unary           = "-"? apply_expr

// Application: juxtaposition or dot
apply_expr      = atom (__ atom / "." _ (int_lit / ident))*
tuple_items     = expression ("," _ expression)* ("," _)?
array_items     = (expression ";" _)+

atom            = literal / ident / paren_expr / record_expr / block / case_expr

paren_expr      = "(" _ (array_items / tuple_items)? _ ")" _
record_expr     = "{" _ record_fields? "}" _
record_fields   = field_init ("," _ field_init)* ("," _)?
field_init      = ident _ ":" _ expression

// Literals
literal         = unit_lit / int_lit / bool_lit / func_lit
unit_lit        = "()" _
int_lit         = digit+ _
bool_lit        = ("true" / "false") !idchar _
func_lit        = "\\" _ params? "->" _ expression
params          = param ("," _ param)* ("," _)?
param           = ident _ ":" _ type_expr

// Lexical elements
keyword         = ("case" / "loop" / "break" / "true" / "false" / "type" / "int" / "bool" / "unit" / "print") !idchar
ident           = !keyword letter idchar* _
wildcard        = "_" !idchar _
idchar          = [a-zA-Z0-9_]
letter          = [a-zA-Z]
digit           = [0-9]

// Patterns
pattern         = wildcard
                / paren_pat
                / record_pat
                / literal
                / ident

paren_pat       = "(" _ (array_pat_items / pattern)? _ ")" _
array_pat_items = (pattern ";" _)+

record_pat      = "{" _ record_pat_fields? "}" _
record_pat_fields = field_pat ("," _ field_pat)* ("," _)?
field_pat       = ident _ ":" _ pattern

// Whitespace and comments
_               = ([ \t\n\r] / comment)*
__              = [ \t]+
comment         = "//" [^\n]* / "/*" (!"*/" .)* "*/"
