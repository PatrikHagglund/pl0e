// PL/0 Level 0 interpreter using PEG grammar
// Single-phase: semantic actions execute during parsing (no AST)
// Sequential only - no loops, no control flow (NOT Turing-complete)

module pl0peg0

import src/peg
import std/os/file
import std/os/path
import std/os/env

// === Environment ===
pub alias env = list<(string, int)>

pub fun env-get(e: env, key: string): int
  match e.filter(fn(p) p.fst == key)
    Cons((_, v), _) -> v
    Nil -> 0

fun env-set(e: env, key: string, v: int): env
  Cons((key, v), e.filter(fn(p) p.fst != key))

// === Semantic Values (Thunks) ===
pub type semval
  SVExpr(f: (env) -> div int)
  SVStmt(f: (env) -> <div,console> env)
  SVIdent(s: string)
  SVOp(op: string)
  SVList(vs: list<semval>)

// Flatten SVList wrappers
fun flatten-sv(vs: list<semval>): list<semval>
  vs.flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })
    .flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })
    .flatmap(fn(c) match c { SVList(inner) -> inner; _ -> [c] })

// === Semantic Actions ===
fun default-action(name: string, txt: string, children: list<semval>): semval
  if name == "_lit" && (txt.trim == "+" || txt.trim == "-")
  then SVOp(txt.trim)
  else match children { Cons(c, Nil) -> c; _ -> SVList(children) }

fun act-int-lit(name: string, txt: string, children: list<semval>): semval
  val digits = txt.list.take-while(fn(c) c.is-digit).string
  SVExpr(fn(_) digits.parse-int.default(0))

fun act-ident(name: string, txt: string, children: list<semval>): semval
  val id = txt.list.take-while(fn(c) c.is-alpha || c.is-digit || c == '_').string
  SVIdent(id)

fun act-term(name: string, txt: string, children: list<semval>): semval
  match flatten-sv(children).filter(fn(c) match c { SVExpr(_) -> True; SVIdent(_) -> True; _ -> False }).head
    Just(SVExpr(f)) -> SVExpr(f)
    Just(SVIdent(id)) -> SVExpr(fn(e) env-get(e, id))
    _ -> SVExpr(fn(_) 0)

fun act-expression(name: string, txt: string, children: list<semval>): semval
  val cs = flatten-sv(children)
  val exprs = cs.filter-map(fn(c) match c { SVExpr(f) -> Just(f); _ -> Nothing })
  val ops = cs.filter-map(fn(c) match c { SVOp(o) -> Just(o); _ -> Nothing })
  match exprs
    Cons(first, rest) -> SVExpr fn(e)
      zip(rest, ops).foldl(first(e)) fn(acc, p)
        if tuple2/snd(p) == "-" then acc - tuple2/fst(p)(e) else acc + tuple2/fst(p)(e)
    _ -> SVExpr(fn(_) 0)

fun act-binding(name: string, txt: string, children: list<semval>): semval
  val cs = flatten-sv(children)
  val id = cs.filter-map(fn(c) match c { SVIdent(s) -> Just(s); _ -> Nothing }).head.default("")
  val f = cs.filter-map(fn(c) match c { SVExpr(f) -> Just(f); _ -> Nothing }).head.default(fn(_) 0)
  SVStmt(fn(e) env-set(e, id, f(e)))

fun act-print(name: string, txt: string, children: list<semval>): semval
  val f = flatten-sv(children).filter-map(fn(c) match c { SVExpr(f) -> Just(f); _ -> Nothing }).head.default(fn(_) 0)
  SVStmt(fn(e) { println(f(e).show); e })

fun act-statement(name: string, txt: string, children: list<semval>): semval
  flatten-sv(children).filter(fn(c) match c { SVStmt(_) -> True; _ -> False }).head.default(SVStmt(fn(e) e))

fun pl0-actions(): actions<semval>
  [("int_lit", act-int-lit), ("ident", act-ident), ("term", act-term),
   ("expression", act-expression), ("binding", act-binding),
   ("print_stmt", act-print), ("statement", act-statement)]

// === Main ===
pub fun main()
  val args = get-args()
  val prog-path = args.head.default("../examples/example_0.pl0")
  val arg1-val = match args { Cons(_, Cons(n, _)) -> n.parse-int.default(0); _ -> 0 }
  val arg2-val = match args { Cons(_, Cons(_, Cons(n, _))) -> n.parse-int.default(0); _ -> 0 }

  "Starting (direct execution, no AST)...".println
  val grammar-text = read-text-file("src/pl0_0.peg".path)
  ("Grammar file read: " ++ grammar-text.count.int/show ++ " chars").println
  val g = parse-peg(grammar-text)
  println("Grammar loaded: " ++ g.length.int/show ++ " rules")

  val prog = read-text-file(prog-path.path)
  println("Program loaded (" ++ prog.count.int/show ++ " chars): " ++ prog-path)

  val acts = pl0-actions()
  var input := prog.slice
  var current-env: env := [("arg1", arg1-val), ("arg2", arg2-val)]

  match peg-exec-partial(g, acts, default-action, "_", input)
    Just((rest, _)) -> input := rest
    Nothing -> ()

  while { !input.is-empty }
    match peg-exec-partial(g, acts, default-action, "statement", input)
      Just((rest, sv)) ->
        match sv { SVStmt(f) -> current-env := f(current-env); _ -> () }
        match peg-exec-partial(g, acts, default-action, "_", rest)
          Just((rest2, _)) -> input := rest2
          Nothing -> input := rest
      Nothing ->
        if !input.is-empty then println("Parse failed at: " ++ input.string.first(20).string ++ "...")
        input := "".slice

  println("")
